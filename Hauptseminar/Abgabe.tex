\documentclass[fleqn,envcountsame,runningheads,10pt,a4paper]{llncs}

\usepackage[latin1]{inputenc}
\usepackage{enumerate} 
\usepackage{verbatim}
\usepackage{moreverb}
\usepackage{subfigure}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{cite}
\usepackage{url}
\usepackage{ngerman}


\pagestyle{headings}

\begin{document}
\title{\glqq RSA: Implementation and Security\grqq\/\newline(Sommersemester 2014)}
\titlerunning{Seminar Hardware Security}
\author{Thomas Stadler}
\authorrunning{Stadler}
\institute{Lehrstuhl f\"ur Technische Informatik}

\maketitle

\begin{abstract}
  Sicherheitsaspekte spielen bei Hardware-Schaltungen eine immer st"arkere
  Rolle. Im Rahmen des Seminars werden neue Themen aus diesem Bereich
  anhand des Buches \cite{TW:12} ausgearbeitet.
\end{abstract}


\section{Einleitung}
Der Wunsch nach gesicherter Übermittlung von Nachrichten ist wohl so alt wie die Kommunikation selbst. In der Geschichte etablierten sich mannigfache Möglichkeiten Texte zu Ver- und Entschlüsseln. Die Grundlage jeder Verschlüsselung ist in der Mathematik zu finden und der Berechnung eines Geeigneten Schlüssels. Je Komplexer die Berechnung, desto schwieriger ist es die Nachricht wieder zu dechiffrieren. Der große Sprung in der Versicherungstechnik kam mit dem Anfang des zwanzigsten Jahrhunderts und der Computertechnologie, die es ermöglichte die Komplexität an eine Maschine weiterzugeben. Dabei ist die Art und Weise der Verschlüsselung noch immer die selbe. Ein Klartext wird durch ein bestimmtes Schema in einen nicht lesbaren Text Übersetzt werden und ebenfalls durch ein festgelegtes Schema wieder zurück-gelesen werden. Das Geheimnis dabei ist recht simpel. Die beiden Kommunikationspartner brauchen einen Schlüssel für die jeweilige Übersetzung. Seit dem Siegeszug der Computer Mitte der 1900er Jahre sind diese Schlüssel Zahlen, die in die Übersetzungs-Algorithmen eingespeist werden. 

\section{Schlüsseltypen}
\label{sec:keytypes}
Man unterscheidet bei der Verschlüsselung zwei Kategorien. Die symmetrische und die asymmetrische Verschlüsselung. Der unterschied der Typen liegt in den Verwendeten Schlüssel. 

\subsection{Symmetrische Verschlüsselung}
\label{sec:symmetric}
Bei dieser Verschlüsselung wird ein Schlüssel erstellt, der sowohl zur Ver- als auch zur Entschlüsselung verwendet wird. Der Algorithmus, der verwendet wird um Klartext zu chiffrieren benötigt also den gleichen Schlüssel um den Chiffretext wieder in Klartext zu Übersetzen. Ein großer Nachteil dieser Technik ist also der Schlüssel selbst. Dieser muss auch gesichert den Kommunikationspartnern übermittelt werden. Sollte der Schlüssel nach Außen gelangen ist die Verschlüsselung nichtig und kann jederzeit gelesen werden. 

\subsection{Asymmetrische Verschlüsselung}
\label{sec:asymmetric}
In diesem Typ werden zwei voneinander verschieden Schlüssel erzeugt. Ein öffentlicher und ein privater Schlüssel. mit dem öffentlichen Schlüssel kann jeder einen Text für den Inhaber des privaten Schlüssels chiffrieren. Dabei ist sichergestellt, das der verschlüsselte Text nur vom Kommunikationspartner entziffert werden kann. Selbst der Inhaber des öffentlichen Schlüssels, kann den Chiffretext mit diesem nicht mehr entschlüsseln. Trotzdem muss der private Schlüssel stets geheimgehalten werden, denn nur mit ihm können Nachrichten entschlüsselt werden. Durch die Verwendung eines gesonderten Schlüssels zur Verschlüsselung stellt diese Art ein Plus an Sicherheit dar, da nicht mehr der eine Schlüssel aus dem symmetrischen Verfahren offen verwendet werden muss um Texte zu chiffrieren. Ein weiterer Aspekt der Sicherheit ist es, dass der private Schlüssel nicht aus dem öffentlichen berechnet werden kann. Sollte also der öffentliche Schlüssel in fremde Hände gelangen ist es weiterhin nicht möglich Chiffretexte zu entschlüsseln.
Der im Nachfolgenden genauer erklährte RSA Algorithmus zählt zu den asymmetrischen Verfahren.

\section{RSA}
\label{sec:symmetric}
Der RSA Algorithmus ist sehr bekannt und weit verbreitet. Doch trotz seines Bekanntheitsgrades gilt diese Verschlüsselung als sehr sicher. Ein Grund für die Verbreitung des Verfahrens ist wohl die einfache mathematische Herleitung des Algorithmus. In diesem Kapitel wird auf die Herleitung und die hardwarespezifische Umsetzung eingegangen.

\subsection{mathematische Herleitung}
\label{sec:mathenatical}
Der erste Schritt der Berechnung ist die Wahl von zwei voneinander verschiedenen, großen und zufälligen Primzahlen, im Weiteren werden diese als P und Q bezeichnet. Die beiden Primzahlen werden verwendet um zwei weitere Zahlen für die Rechnung zu ermitteln, \( N = P \cdot Q \) und \( \psi = (P - 1) \cdot (Q - 1) \). Als nächstes wird eine Zahl E ermittelt für die gilt: \( 1 < E < \psi \) und E ist teilerfremd zu $\psi$. Durch E und $\psi$ wird eine weitere Zahl berechnet, für die gilt: \(D\cdot E = 1 mod \psi\). 
Nach der Ermittlung aller benötigten Zahlen, N E und D, können die Schlüssel erzeugt werden. Dabei werden die Zahlen N und E für den öffentlichen Schlüssel verwendet, N und D für den privaten.\\
Um nun einen Klartext in einen Chiffretext zu überführen muss die Nachricht in eine natürliche Zahl I umgewandelt werden. Unter Verwendung von E und N kann die Umrechnung wie folgt ausgeführt werden:\\
\(C = I^E mod N\)\\
Das Dechiffrieren funktioniert sehr ähnlich zum Verschlüsseln. Mit den Zahlen N und D des privaten Schlüssels wird die Nachricht folgendermaßen zurückgerechnet:\\
\(I = C^D mod N\)\\
\linebreak
Interessanterweise gestaltet sich die mathematische Herleitung des Algorithmus sehr einfach und die Ver- und Entschlüsselung können mit jeweils einem mathematischen Ausdruck ermittelt werden. Um die Schwierigkeiten der Implementation des RSA zu verstehen, müssen die Herleitungsschritte genauer betrachtet werden.

\subsubsection{Sicherheit der Herleitung}

Schon der erste Schritt der Herleitung entpuppt sich als der vielleicht schwierigste und zugleich wichtigste. Aus zwei großen, voneinander verschiedenen und zufälligen Primzahlen wird durch Multiplikation die Zahl N erzeugt, die sowohl teil des privaten als auch des öffentlichen Schlüssels ist. Sollte der öffentliche Schlüssel eines Kommunikationspartners bekannt werden, wäre es für einen Angreifer ein Leichtes alle anderen Zahlen zu ermitteln und den Algorithmus zu knacken, sofern er die beiden Primzahlen errechnen kann. Doch hier zeigt eine Barriere, die Teil des Fundamentalsatzes der Arithmetik is: Es existiert kein Verfahren das die Primfaktorzerlegung einer Zahl in polynomialer Zeit errechnen kann. \\
Jedoch kann man mit modernen Computern einfach alle Möglichkeiten der Faktorisierung durchprobieren. Um dieser einfachen Methode entgegenzuwirken, müssen die Zahlen P und Q sehr groß gewählt werden. Damit kann sichergestellt werden, dass es unrealistisch ist, dass ein Brute-Force Anschlag in ab-wartbarer Zeit zum Erfolg führt. Zur gegenwärtiger Zeit ist eine Größenordnung von 1024 oder 2048 Bit für die Primzahlen gängig.\\

\subsubsection{Komplexität der Herleitung}
Der Vorteil der sich für die Sicherheit aus der Wahl der großen Primzahlen ergibt, ist jedoch ein Nachteil für die Komplexität des Algorithmus, da sie Zahlen sehr schwer zu bestimmen sind. Dabei stellt jedoch jede Forderung an die die Zahlen ein plus an Sicherheit auf kosten der Komplexität dar.\\
 Um einer Brute-Force Attacke entgegenzuwirken müssen die Zahlen sehr große sein.  Die Zahlen müssen voneinander verschieden sein, da sonnst ein Angreifer ein Quadrat erkennen könnte und damit die Zeit um die Primfaktorzerlegung durchzuführen signifikant senken kann. Die letzte Anforderung ist dabei die wohl wichtigste und zugleich am schwierigsten zu erzeugende. Die Zahlen müssen prim sein, da sonst das Produkt der beiden mehr Teiler hat als die Zahlen selbst.\\
  Das Erzeugen von Primzahlen gestaltet sich jedoch als sehr schwer. in einer Größenordnung \(2^512\) ist eine von 200 Zahlen prim. Dennoch kann ein Zahlengenerator bei ausreichender Zeit eine Primzahl finden. Doch der gefundene Wert muss noch validiert werden.  Der Standartprozess für die Prüfung ist es, die vermeintliche Primzahl P durch alle Zahlen des Intervalls [1;$\sqrt{P}$] zu teilen. Trotzdem ist die Berechnung deterministisch und in polynomialer Zeit lösbar.\\
Ein weiteres grundsätzliches Problem sind die beiden Produkte für N und $\psi$  mit den Multiplikatoren P und Q. Kosten und Zeit deines Systems, dass den RSA verwendet, werden direkt von der Wahl des Multiplikationssystems beeinflusst.\\
Total sicher ist der RSA Algoryithmus jedoch nicht, denn er kann bei ausreichender Zeit geknackt werden. Werden die Primzahlen jedoch so hoch angesetzt, dass es unrealistisch wird den Algorithmus in polynomialer Zeit zu knacken, so ist diese Zeit zugleich das Herzstück der Sicherheit dieser Verschlüsselung.


\subsection{Hardware Implementierung}
In der Hardware Implementierung zeigt sich die Schwierigkeit der Multiplikation von großen Zahlen. Wie oben erwähnt ist die Grundlage des Algorithmus die Multiplikation von zwei mindestens 512 BIt großen Zahlen. im folgenden wird auf verschiedene Möglichkeiten eingegangen diese Problematik zu behandeln und in ein RSA Verschlüsselungssystem zu integrieren. 

\subsubsection{Kombinatorischer Multiplizierer}
für die Multiplikation zweier n-bit Zahlen werden \(n^2\) Volladdierer benötigt. Diese Volladdierer werden zu einer n x n großen Matrix zusammengeschlossen, die das Ergebnis der Multiplikation nach dem selben Prinzip wie bei der Multiplikation von Hand ermitteln. Jede Reihe des Kombinatorischen Multiplizierers berechnet dabei ein  Teilergebnis, die wiederum am Ende zusammenaddiert werden. Diese Methode berechnet das Multiplikationsergebnis in konstanter Zeit. Die Anzahl der Volladdierer die jedes Bit durchlaufen muss ist jedoch sehr hoch und wächst exponentiell mit der Größe der Primzahlen P und Q. So wird die konstante Zeit unausführbar lange. In der Praxis kommt der Combinatorische Multiplizierer wie hier dargestellt auf grund der Zeit und Kosten sehr selten zum Einsatz. 


\subsubsection{bit serieller Multiplizierer}
Diese Methode verwendet ein 

\subsubsection{Hybrid}

\subsection{Sicherheitsanalyse}
Nach der Tiefenanalyse der Hardware Implementierung ist es an der Zeit die Anforderungen an ein Kryptosystem zu prüfen. Im letzten Kapitel ist klar geworden, wie umfangreich und komplex die Berechnungen der Multiplikationen zu Stande kommen. Dennoch muss sichergestellt sein das immer das Richtige Ergebnis ermittelt wird. Denn bei einem so komplexen bauteil können sich kleine Fehler einschleichen, die auswiken könne, dass der Algorithmus nicht mehr funktioniert. Also das Chiffretext nicht mehr encodiert werden kann. Weiter müssen die gewünschten längen der Schlüsses so gewählt werden das sie einen ausreichenden Schutz bieten. Ferner muss ein solches System robust sein, was Angriffe angeht, seien es bereits bekannte Methoden oder auch nur theoretische Überlegungen. \\
Kernstück der Sicherheit stellt das Lösbarkeitsproblem der Primfaktorzerlegung dar. Daher ist jede Anforderung 'groß', 'zufällig', 'voneinander verschieden' und 'prim' ein plus an Sicherheit. \\
Seit der Publizierung des Algorithmus 1979 wuchs die größe der Zahlen stetig an. Geschuldet ist das den modernen Prozessoren und deren Rechengeschwindigkeit. Daher müssen die Zahlen so groß gewählt werden, dass eine Brute-Force Attacke unwahrscheinlich ist in polynomialer Zeit zu determinieren. Momentan gelten Zahlen im Bereich von 2048 oder 4096 als sicher.\\
Wenn in der Zufälligkeit eine Unausgewogenheit herrscht kann ein Angreifer das Zahlenfeld eingrenzen und damit die Zeit die er brauchen würde die Primfaktorisierung durchzuführen signifikant verkürzen.\\
Sollten die beiden Zahlen gleich sein, kann man aus dem Produkt eine Quadratzahl erkennen und die Faktorisierung sofort durchführen. Auch wenn der Abstand der Zahlen zu gering oder viel zu groß ist,  wird die Verschlüsselung anfällig für andere Arten die Faktorisierung zu knacken.\\
Die letzte Anforderung, dass die Zahlen prim sein müssen ist wie bereits angesprochen die wichtigste und zugleich die am schwierigsten zu kontrollierende. Denn wenn die Zahlen nicht prim wären, so würden mehrere Faktorisierungen existieren und das würde die Komplexität des Algorithmus enorm vermindern. \\
Ein weiterer Ansatz für Angreifer ist die Zahl E, die im Kapitel der Herleitung als \( 1 < E < \psi \) teilerfremd zu $\psi$ definiert wurde. In der Entschlüsselung \(C = I^E mod N\)\\ ist E ein teil des privaten Schlüssels und damit sehr interessant für Angriffe. 



\subsection{Fazit}





\bibliographystyle{splncs}
\bibliography{literatur}


\end{document}
